'''
Есть несколько вариантов решение данных заданий.
1. Написание универсальной функции и последующие уникальные вызовы в генеративном варианте
2. Написание отдельных функций и последующих вызовов с помощью циклов
3. Есть вариации по самому заданию: 1/2/3 кучи, условие на выигрыш/проигрыш
'''

'''На 2 кучи'''
# P-00 (демо-2021). Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
# (по своему выбору) один камень или увеличить количество камней в куче в два раза.
# Игра завершается в тот момент, когда суммарное количество камней в кучах становится не менее 77.
# Победителем считается игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой
# в кучах будет 77 или больше камней. В начальный момент в первой куче было семь камней, во второй куче – S камней; 1 ≤ S ≤ 69.

# Задание 19.
# Известно, что Ваня выиграл своим первым ходом после неудачного
# первого хода Пети. Укажите минимальное значение S, когда такая ситуация возможна.

# Задание 20.
# Найдите два таких значения S, при которых у Пети есть
# выигрышная стратегия, причём одновременно выполняются два условия:
# − Петя не может выиграть за один ход;
# − Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.

# Задание 21
# Найдите минимальное значение S, при котором одновременно выполняются два условия:
# – у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

'''Вариант универсальной функции '''
# def strategy(s_1, s_2, prev_n, n):#s_1 - количество камней 1 кучи / s_2 - количество камней  2 кучи/ prev_n - количество СОВЕРШЕННЫХ ходов /n - количество ходов
#    if s_1 + s_2 >= 77:  # игра завершилась ровно или менее prev_n ходов
#        return prev_n % 2 == n % 2
#    if prev_n == n:# ходов больше нет
#        return 0
#    variants = [strategy(s_1 + 1, s_2,  prev_n + 1, n),
#                strategy(s_1, s_2 + 1, prev_n + 1, n),
#                strategy(s_1 * 2, s_2,  prev_n + 1, n),
#               strategy(s_1, s_2 * 2, prev_n + 1, n)]
#    return any(variants) if (prev_n - 1) % 2 == n % 2 else all(variants)

# print ([s for s in range(1, 70) if strategy(7, s, 0, 2)] )
# print ([s for s in range(1, 70) if not strategy(7, s,0, 1) and strategy(7, s,0, 3)] )
# print ([s for s in range(1, 70) if not strategy(7, s,0, 2) and strategy(7, s,0, 4)])

'''Вариант уникальной функции '''
# 5 ХОДОВ:
# 1 - начало игры
# 2 - Петя
# 3 - Ваня
# 4 - Петя
# 5 - Ваня

# def simpleFunc19(s_1, s_2, step):
#     if s_1 + s_2 >= 77 and step == 3:
#         return True
#     elif s_1 + s_2 < 77 and step == 3:
#         return False
#     elif s_1 + s_2 >= 77 and step < 3:
#         return False
#     return simpleFunc19(s_1 + 1, s_2, step + 1) or \
#         simpleFunc19(s_1, s_2 + 1, step + 1) or \
#         simpleFunc19(s_1 * 2, s_2, step + 1) or \
#         simpleFunc19(s_1, s_2 * 2, step + 1)
#
#
# def simpleFunc20(s_1, s_2, step):
#     if s_1 + s_2 >= 77 and step == 4:
#         return True
#     elif s_1 + s_2 < 77 and step == 4:
#         return False
#     elif s_1 + s_2 >= 77 and step < 4:
#         return False
#
#     if step % 2 == 1:  # ходы Вани
#         return simpleFunc20(s_1 + 1, s_2, step + 1) or \
#             simpleFunc20(s_1, s_2 + 1, step + 1) or \
#             simpleFunc20(s_1 * 2, s_2, step + 1) or \
#             simpleFunc20(s_1, s_2 * 2, step + 1)
#     else:  # ходы Пети
#         return simpleFunc20(s_1 + 1, s_2, step + 1) and \
#             simpleFunc20(s_1, s_2 + 1, step + 1) and \
#             simpleFunc20(s_1 * 2, s_2, step + 1) and \
#             simpleFunc20(s_1, s_2 * 2, step + 1)
#
#
# def simpleFunc21(s_1, s_2, step):
#     if s_1 + s_2 >= 77 and (step == 3 or step == 5):
#         return True
#     elif s_1 + s_2 < 77 and step == 5:
#         return False
#     elif s_1 + s_2 >= 77 and step < 5:
#         return False
#
#     if step % 2 == 0:  # ходы Пети
#         return simpleFunc21(s_1 + 1, s_2, step + 1) or \
#             simpleFunc21(s_1, s_2 + 1, step + 1) or \
#             simpleFunc21(s_1 * 2, s_2, step + 1) or \
#             simpleFunc21(s_1, s_2 * 2, step + 1)
#     else:  # ходы Вани
#         return simpleFunc21(s_1 + 1, s_2, step + 1) and \
#             simpleFunc21(s_1, s_2 + 1, step + 1) and \
#             simpleFunc21(s_1 * 2, s_2, step + 1) and \
#             simpleFunc21(s_1, s_2 * 2, step + 1)
#
#
# print([s for s in range(1, 70) if simpleFunc21(7, s, 1)])

'''Самостоятельное задание'''
# Два игрока играют в следующую игру.
# Перед ними лежат три кучки камней, в первой из которых 2, во второй – 3, в третьей – S (1 ≤ S ≤ 19) камней.
# У каждого игрока неограниченно много камней. Игроки ходят по очереди.
# Ход состоит в том, что игрок или удваивает число камней в какой-то куче или добавляет по два камня в каждую из куч.
# Выигрывает игрок, после хода которого в одной из куч становится не менее 20 камней,
# или общее число камней во всех трех кучах становится не менее 25.

# 19. Укажите такое значение S, при котором Петя не может выиграть за один ход,
# но при любом ходе Пети Ваня может выиграть своим первым ходом.

# 20. Для игры, описанной в предыдущем задании, найдите два наименьших значения S,
# при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
# − Петя не может выиграть за один ход;
# − Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.

# 21. Для игры, описанной в задании 19, найдите минимальное значение S,
# при котором одновременно выполняются два условия:
# – у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

#1 ход - начало игры
# 2 ход - ход Пети
# 3 ход - ход Вани

# def game19(s_1, s_2, s_3, step):
#     if (s_1 >= 20 or s_2 >= 20 or s_3 >= 20 or s_1 + s_2 + s_3 >= 25) and step == 3:
#         return True
#     if (s_1 >= 20 or s_2 >= 20 or s_3 >= 20 or s_1 + s_2 + s_3 >= 25) and step != 3:
#         return False
#     if not (s_1 >= 20 or s_2 >= 20 or s_3 >= 20 or s_1 + s_2 + s_3 >= 25) and step == 3:
#         return False
#
#     if step % 2 != 0:
#         return

'''На одну кучу'''
# P-02 (демо-2023). Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит
# куча камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить
# в кучу один камень или увеличить количество камней в куче в два раза. Для того чтобы делать ходы,
# у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент,
# когда количество камней в куче становится не менее 129. Победителем считается игрок,
# сделавший последний ход, т.е. первым получивший кучу, в которой будет 129 или больше камней.
# В начальный момент в куче было S камней, 1 ≤ S ≤ 128.

# Задание 19.
# Укажите такое значение S, при котором Петя не может выиграть за один ход, но при любом ходе
# Пети Ваня может выиграть своим первым ходом.
#   ПВ - 2 хода

# Задание 20.
# Найдите два таких значения S, при которых у Пети есть выигрышная стратегия,
# причём одновременно выполняются два условия:
# ПВП - 3
# − Петя не может выиграть за один ход;
# − Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.

# Задание 21
# Найдите значение S, при котором одновременно выполняются два условия:
# ПВ - 2 хода или ПВПВ - 4 хода
# – у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

# def strategy(s, m):      #s - количество камней кучи / m - количество ходов
#     if s >= 129:
#         return m % 2 == 0
#     if m == 0:
#         return 0
#     if m % 2 != 0:
#         return strategy(s + 1, m - 1) or strategy(s * 2, m - 1)         # первый
#     else:
#         return strategy(s + 1, m - 1) and strategy(s * 2, m - 1)         # второй
#
# print('19: ', [s for s in range(1, 129) if strategy(s,2)] )
# print('20: ', [s for s in range(1, 129) if not strategy(s, 1) and strategy(s,3)] )
# print('21: ', [s for s in range(1, 129) if not strategy(s, 2) and strategy(s,4)] )

'''Вариант дополнительный условий для рекурсивной функции'''
# def strategy(s_1 , s_2, prev_n, n):
#     if s_1 + s_2 <= 20:
#         return prev_n % 2 == n % 2
#     if prev_n == n:
#         return 0
#     if s_1 % 2 != 0:
#         s_1_h = s_1 // 2 + 1
#     else:
#         s_1_h = s_1 // 2
#
#     if s_2 % 2 != 0:
#         s_2_h = s_2 // 2 + 1
#     else:
#         s_2_h = s_2 // 2
#     variants = [strategy(s_1 - 1, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2 - 1, prev_n + 1, n),
#                 strategy(s_1_h, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2_h, prev_n + 1, n)]
#     return any(variants) if (prev_n + 1) % 2 == n % 2 else all(variants)
#
# print('19: ', [s for s in range(11, 100) if strategy(10, s, 0, 2)] )
# print('20: ', [s for s in range(11, 100) if not strategy(7, s,0, 1) and strategy(7, s,0, 3)] )

'''Вариант суммирования куч'''
# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну
# из куч один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы,
# у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент,
# когда суммарное количество камней в кучах становится не менее 69.
# Победителем считается игрок, сделавший последний ход, т. е. первым получивший позицию,
# в которой в кучах будет 69 или больше камней.
# В начальный момент в первой куче было 5 камней, во второй куче – S камней, 1 ≤ S ≤ 63.
# Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
# Ответьте на следующие вопросы:

# 19. Известно, что Ваня выиграл своим первым ходом после
# неудачного первого хода Пети. Назовите минимальное значение S, при котором это возможно.
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня


# 20. Найдите два таких значения S, при которых у Пети есть
# выигрышная стратегия, причём Петя не может выиграть первым ходом,
# но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня

# 21. Укажите минимальное значение S, при котором у Вани есть
# выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом
# при любой игре Пети, и при этом у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
#
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня

#19
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2 < 69 and step == 3:        #ход Вани но камней мало - проигрыш
#         return False
#     elif s_1 + s_2  >=69 and step == 3:     #ход Вани и камней нужное количество - выигрыш
#         return True
#     elif s_1 + s_2  >=69 and step < 3:     #ход НЕ Вани и камней нужное количество - выигрыш НЕ у вани
#         return False
#     return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('19: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])

# #20
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2  >=69 and step == 4:
#         return True
#     elif s_1 + s_2 < 69 and step == 4:
#         return False
#     elif s_1 + s_2  >=69 and step < 4:
#         return False
#
#     if step % 2 == 1:   #ходы ВАНИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#     else:   #ходы ПЕТИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) and simpleFunc(s_1, s_2 + 1, step + 1) and simpleFunc(s_1 * 2, s_2, step + 1) and simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('20: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])


#21
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2  >=69 and (step == 3  or step == 5):
#         return True
#     elif s_1 + s_2 < 69 and step == 5:
#         return False
#     elif s_1 + s_2  >=69 and step < 5:
#         return False
#
#     if step % 2 == 0:   #ходы ПЕТИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#     else:   #ходы ВАНИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) and simpleFunc(s_1, s_2 + 1, step + 1) and simpleFunc(s_1 * 2, s_2, step + 1) and simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('21: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])

'''На меньшее количество'''
#120)(А. Богданов) Два игрока, Петя и Ваня, играют в следующую игру.
# Перед игроками лежит две кучи камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может убрать из любой
# кучи один или три камня. Игра завершается в тот момент, когда
# количество камней в любой из куч становится менее 10. Победителем
# считается игрок, сделавший последний ход, т.е. первым получивший кучу,
# в которой меньше 10 камней. Будем говорить, что игрок имеет выигрышную
# стратегию, если он может выиграть при любых ходах противника.

# Задание 19.
# В начальный момент в кучах было по S камней. Найдите такое значение S,
# при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

# Задание 20.
# Известно, что в первой куче 13 камней, а во второй – S камней (S ≥ 10).
# Найдите наименьшее и наибольшее значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
#     – Петя не может выиграть за один ход;
#     – Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Запишите в ответе сначала наименьшее значение, потом – наибольшее.

# Задание 21
# Известно, что в первой куче 13 камней, а во второй – S камней (S ≥ 10).
# Найдите наименьшее и наибольшее значения S, при котором одновременно выполняются два условия:
# — у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# — у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
# Запишите в ответе сначала наименьшее значение, потом – наибольшее.

# def  simpleFunc (s_1,s_2, step):
#     if s_2 < 0 or s_1 < 0:
#         return False
#     elif  (s_2 <= 10 or s_1 <= 10) and (step == 3 or step == 5):
#         return True
#     elif (s_2 > 10  or s_1 > 10) and step == 5:
#         return False
#     elif (s_2 <= 10 or s_1 <= 10) and step < 5:
#         return False
#
#     if step % 2 == 0 :
#         return simpleFunc(s_1 - 1, s_2,  step +  1 ) or  simpleFunc(s_1 -  3, s_2,  step +  1 ) or  simpleFunc (s_1 , s_2 - 1,  step +  1 ) or  simpleFunc (s_1 , s_2 - 3,  step +  1 )
#     else:
#         return simpleFunc(s_1 - 1, s_2, step + 1) and simpleFunc(s_1 -  3, s_2,  step +  1 ) and  simpleFunc (s_1 , s_2 - 1,  step +  1 ) and  simpleFunc (s_1 , s_2 - 3,  step +  1 )
#
# print('21: ', [s for s in range(10, 1000) if simpleFunc(13, s, 1)])

'''Вариация с дроблением на функции'''
# def endGame(x):
#     return x >= 166
#
# def getNext(x):
#     move = [x + 2, x + 10]
#     i = 2
#     while i * x - x <= 80:
#         move.append(i * x)
#         i +=1
#     return move
#
# def f(position, m):
#     if endGame(position):
#         return m % 2 == 0
#     if m == 0:
#         return 0
#
#     variants = [f(i, m - 1) for i in getNext(position)]
#     return  any(variants) if m % 2 != 0 else all(variants)
#
# print([s for s in range(1, 166) if f(s, 3) ])
# print([s for s in range(1, 166) if not f(s, 1) and f(s,3)])
# print([s for s in range(1, 166) if not f(s, 2) and f(s,4)])
